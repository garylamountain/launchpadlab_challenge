# Launchpad Lab Challenge

## Chronicling the Process
I'd like to use this section as a sort of journal to record my thought process as I create this app.

[01/17]
Initial thoughts on how to meet the requirements of this challenge. I need to:
1. Decide which metrics to use to determine the "best" framework (without knowing much about the culture surrounding Github, I assume commits will be an important factor? More commits might equate to a more actively updated framework.)
2. Figure out how to fetch information from each of these repos with Github's API (hopefully it won't be too hard to figure out with the Fetch API!)
3. Display this information in a way that promotes the user to make a well-informed decision (I wonder if I could find a log of this data over time, i.e. how many commits were made to the repo within the past year vs the past week, etc.)
4. Ensure that a user can only vote once per email address and browser session, and that the tally of total votes is accessible (should be easy using rails as an API?)

To address the first of these, I'm going to do some light research on what metrics make a "good" Github repo/project. I've read a few articles in the vein of this https://blog.tidelift.com/dont-judge-a-project-by-its-github-stars-alone which all say that stars and forks are the two most commonly-used (but potentially flawed) metrics to measure a Github's popularity. Stars can work as favorites or bookmarks, which hopefully demonstrate some sort of interest in a repo. Forks show interest in improving the content of a project, which again definitely demonstrates some sort of interest. For my third metric, I'm choosing to use commits for the reason stated above; I assume that a more actively updated framework probably has fewer bugs or other issues and may have more features). 

Now moving on to the second task at hand, I need to figure out how to fetch information about a Github. I also need to see what information is avaliable to me; I'd like to do a comparison of my three metrics over time, to better determine which framework is currently the most active. I plan to start with simply making a single GET request to Github's API using the fetch API, console logging the response and using their documentation to determine how to proceed (https://developer.github.com/v3/). Thankfully, their documentation seems pretty good. It also turns out there is some tracking of these stats over time: https://developer.github.com/v3/repos/statistics/#get-the-last-year-of-commit-activity-data. Unfortunately, only commits over time seem to be avaliable through the API. This means that for stars and forks, I may only be able to display the current, total number of each.

[01/20]
I'm continuing on with the frontend before making any moves to persist data on the backend. I'm going to create a quick table where I can show all the relevant info from my data fetches. I'm going to make a basic HTML table, each row is a framework and columns are their respective Github metrics. Everytime I call my data fetching function, I simply overwrite each "cell's" innerHTML with the new value I get from the GET request. Now, I need to create a way for the user to vote on their preferred framework; a dropdown or radio buttons make the most sense to me here. I've created a dropdown with the four frameworks listed, a prompt, an input field for their email and a "vote" button. The last steps are to fetch new data without having to refresh the page, allow a user to actually submit a vote and verify if they have already, and connect it all to a backend.

[01/21]
I'm going to begin by finding a means of fetching new data continuously without having to refresh the page. I feel like a timing event would be useful here; wrap my data fetching function in a set interval function that will call the method every 30 seconds or so, indefinitely. I used setInterval to call the fetchData function every 30 seconds, and it works as expected. 

The next step is to allow a user to vote. In order to proceed, I'm going to have to set up a backend now. I predict I can use two models in the backend: a framework model and a vote model. Each framework object will have a name (React, Angular, etc.) and # of votes. Each vote object will have a respective framework and an email address. With this configuration, when a user submits a vote, I can check the vote objects to see if their email address is already assigned to a framework. If it isn't, I can create a new vote object and also edit the correct framework to increment its number of votes by 1. If the user's email address is already in use, I'll simply return with "Sorry, you've already voted once." 

The models have been created, and I've seeded the database with the four frameworks and 0 initial votes. Now I just have to attach an event listener to the Vote button which will send a GET request to the /votes endpoint when a user submits a vote. Ideally, if the response shows they haven't voted yet, I can create a POST request which will both create a vote object and increment the framework object's number of votes in one go. I'm beginning by creating index routes for both models: this fulfills the requirement of making the tally of votes accessible through one API route. I'm also going to define a create method in the votes controller that will both create a new vote object and also increment the vote tally of the appropriate framework by one. This was easy to make, and now I'm implementing it in the javascript. When a user submits a vote, a GET request is made to the backend that gets all vote objects. All of the email addresses from all of the votes are pushed into an array. If the email address typed on the screen already exists in the array, the user is told they've already voted. If the email address is not found in the array of existing emails, a vote is created with this nwe email address and the framework selected from the dropdown. I also added in a brief message using javascript string interpolation which displays the percentage of votes that went to each framework so far; I feel like this is a normal thing to expect when you take a poll. All that's left to do is some quick validation to make sure the user is actually inputting a valid email address. I was able to easily find a regex string that checks if an email address looks valid, and incorporated it into a new function that passes in the entered email address before submitting the user's vote. With this I feel I've met the MVP of this application.